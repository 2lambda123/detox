"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7801],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,d=p["".concat(l,".").concat(m)]||p[m]||h[m]||a;return n?i.createElement(d,s(s({ref:t},u),{},{components:n})):i.createElement(d,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<a;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},241:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var i=n(7462),o=n(3366),a=(n(7294),n(3905)),s=["components"],r={id:"synchronization",slug:"troubleshooting/synchronization",title:"Dealing With Synchronization Issues in Tests",sidebar_label:"Dealing With Synchronization Issues in Tests"},l=void 0,c={unversionedId:"synchronization",id:"synchronization",isDocsHomePage:!1,title:"Dealing With Synchronization Issues in Tests",description:"Dealing With Synchronization Issues in Tests",source:"@site/../docs/Troubleshooting.Synchronization.md",sourceDirName:".",slug:"/troubleshooting/synchronization",permalink:"/Detox/docs/troubleshooting/synchronization",editUrl:"https://github.com/wix/Detox/edit/master/docs/../docs/Troubleshooting.Synchronization.md",tags:[],version:"current",frontMatter:{id:"synchronization",slug:"troubleshooting/synchronization",title:"Dealing With Synchronization Issues in Tests",sidebar_label:"Dealing With Synchronization Issues in Tests"},sidebar:"tutorialSidebar",previous:{title:"Dealing With Problems With Running Tests",permalink:"/Detox/docs/troubleshooting/running-tests"},next:{title:"Dealing With Flakiness in Tests",permalink:"/Detox/docs/troubleshooting/flakiness"}},u=[{value:"Dealing With Synchronization Issues in Tests",id:"dealing-with-synchronization-issues-in-tests",children:[{value:"What operations do we try to synchronize with automatically",id:"what-operations-do-we-try-to-synchronize-with-automatically",children:[],level:3},{value:"Automatic synchronization works most of the time",id:"automatic-synchronization-works-most-of-the-time",children:[],level:3},{value:"Are we waiting too much or not waiting enough?",id:"are-we-waiting-too-much-or-not-waiting-enough",children:[],level:3},{value:"Identifying which synchronization mechanism causes us to wait too much",id:"identifying-which-synchronization-mechanism-causes-us-to-wait-too-much",children:[{value:"Lower-level Idling Resources Debug (iOS Only)",id:"lower-level-idling-resources-debug-ios-only",children:[],level:4}],level:3},{value:"Switching to manual synchronization as a workaround",id:"switching-to-manual-synchronization-as-a-workaround",children:[{value:"How do we turn off automatic synchronization?",id:"how-do-we-turn-off-automatic-synchronization",children:[{value:"Controlling the entire synchronization mechanism",id:"controlling-the-entire-synchronization-mechanism",children:[],level:5},{value:"Controlling network synchronization",id:"controlling-network-synchronization",children:[],level:5}],level:4},{value:"How do we wait manually?",id:"how-do-we-wait-manually",children:[],level:4}],level:3},{value:"Tweaking and fine-tuning the synchronization mechanisms",id:"tweaking-and-fine-tuning-the-synchronization-mechanisms",children:[],level:3},{value:"Modifying your app to avoid waiting too much",id:"modifying-your-app-to-avoid-waiting-too-much",children:[{value:"setTimeout and setInterval",id:"settimeout-and-setinterval",children:[],level:4},{value:"Endless looping animations",id:"endless-looping-animations",children:[],level:4}],level:3}],level:2}],h={toc:u};function p(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"dealing-with-synchronization-issues-in-tests"},"Dealing With Synchronization Issues in Tests"),(0,a.kt)("p",null,"Traditionally, one of the most difficult aspects of E2E testing is synchronizing the test scenario with the app. Complex operations inside the app (like accessing servers or performing animations) often take variable amount of time to complete. We can't continue the test until they've completed. How can we synchronize the test with these operations?"),(0,a.kt)("p",null,"Synchronizing manually with ",(0,a.kt)("inlineCode",{parentName:"p"},"sleep()")," commands is a bad idea. It's flaky, complicates the tests, behaves differently on different machines and makes tests needlessly slow."),(0,a.kt)("p",null,"Instead, Detox tries to synchronize the test with the app completely ",(0,a.kt)("em",{parentName:"p"},"automatically"),"."),(0,a.kt)("p",null,"When this works it's like magic. You simply execute actions one after the other without worrying about timing, and Detox waits for the app to stabilize before moving to the next test line. If there's an in-flight request to a server, for example, the test will not move forward until the request completes."),(0,a.kt)("h3",{id:"what-operations-do-we-try-to-synchronize-with-automatically"},"What operations do we try to synchronize with automatically"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Network requests")," - Detox monitors in-flight requests over the network.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Main thread (native)")," - Detox monitors pending native operations on the main thread (main dispatch queue and main NSOperationQueue).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Layout of UI")," - Detox monitors UI layout operations. There's also special support for React Native layout which includes the Shadow Queue where ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/yoga"},"yoga")," runs.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Timers")," - Detox monitors timers (explicit asynchronous delays). There's special support for JavaScript timers like setTimeout and setInterval.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Animations")," - Detox monitors active animations and transitions. There's special support for React Native animations with the Animated library.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"React Native JavaScript thread")," - Detox monitors pending operations on the JavaScript thread in RN apps.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"React Native bridge")," - Detox monitors the React Native bridge and asynchronous messages sent on it."))),(0,a.kt)("h3",{id:"automatic-synchronization-works-most-of-the-time"},"Automatic synchronization works most of the time"),(0,a.kt)("p",null,"It's difficult for an automatic mechanism to be correct in 100% of the cases. There are always exceptions. We are optimizing for the common case so most of your scenarios will not have to deal with synchronization issues."),(0,a.kt)("p",null,"For the rest of this tutorial, we'll assume the test is having some sort of a synchronization issue."),(0,a.kt)("h3",{id:"are-we-waiting-too-much-or-not-waiting-enough"},"Are we waiting too much or not waiting enough?"),(0,a.kt)("p",null,"When the automatic synchronization mechanism doesn't work, we have 2 potential problems:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We are waiting too much - The test will appear to hang and fail with timeout. This happens because Detox thinks an asynchronous operation is currently taking place and is waiting for it endlessly.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We are not waiting enough - The test will appear to fail at some point because an element isn't found according to an expectation or isn't found when attempting to perform an action on it. This happens because Detox didn't take some asynchronous operation into account and isn't waiting until it completes."))),(0,a.kt)("h3",{id:"identifying-which-synchronization-mechanism-causes-us-to-wait-too-much"},"Identifying which synchronization mechanism causes us to wait too much"),(0,a.kt)("p",null,"Interactions with the application are synchronized, meaning that they will not execute unless the app is idle. You may encounter situations where the tests just hang.\nWhen an action/expectation takes a significant amount of time use this option to print device synchronization status.\nThe status will be printed if the action takes more than ","[value]"," (in ms) to complete"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"detox test --debug-synchronization 500\n")),(0,a.kt)("p",null,"Then, reproduce your issue, and you should see output similar to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plain",metastring:"text",text:!0},"18:11:41 detox[15415] INFO:  [actions.js] The system is busy with the following tasks:\n18:11:41 \n18:11:41 Dispatch Queue\n18:11:41 \u23f1 Queue: \u201cMain Queue (<OS_dispatch_queue_main: com.apple.main-thread>)\u201d with 1 work item\n18:11:41 \n18:11:41 Run Loop\n18:11:41 \u23f1 \u201cMain Run Loop\u201d\n18:11:41 \n18:11:41 One-time Events\n18:11:41 \u23f1 \u201cNetwork Request\u201d with object: \u201cURL: \u201chttp://localhost:9001/delay/3000\u201d\u201d\n")),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/wix/DetoxSync/blob/master/IdleStatusDocumentation.md"},"this document")," for documentation of the synchronization debut output."),(0,a.kt)("h4",{id:"lower-level-idling-resources-debug-ios-only"},"Lower-level Idling Resources Debug (iOS Only)"),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"--debug-synchronization")," does not provide the necessary information, on iOS you can add the following launch argument to your app (using ",(0,a.kt)("inlineCode",{parentName:"p"},"launchArgs")," in your ",(0,a.kt)("inlineCode",{parentName:"p"},"launchApp()")," call) to enable a very verbose logging of the idling resource system to the system log:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"-DTXEnableVerboseSyncSystem YES -DTXEnableVerboseSyncResources YES\n")),(0,a.kt)("p",null,"You can then obtain this log by running the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"xcrun simctl spawn booted log stream --level debug --style compact --predicate \"category=='SyncManager'\"\n")),(0,a.kt)("p",null,"For example, change your ",(0,a.kt)("inlineCode",{parentName:"p"},"/e2e/init.js")," like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await detox.init(undefined, { launchApp: false });\nawait device.launchApp({\n  newInstance: true,\n  launchArgs: { 'DTXEnableVerboseSyncSystem': 'YES', 'DTXEnableVerboseSyncResources': 'YES' }\n});\n")),(0,a.kt)("h3",{id:"switching-to-manual-synchronization-as-a-workaround"},"Switching to manual synchronization as a workaround"),(0,a.kt)("p",null,"We always have the fail-safe of turning off automatic synchronization and waiting manually by ourselves. This isn't the recommended approach but sometimes we don't have a choice."),(0,a.kt)("h4",{id:"how-do-we-turn-off-automatic-synchronization"},"How do we turn off automatic synchronization?"),(0,a.kt)("p",null,"This makes sense only if we're waiting too much."),(0,a.kt)("h5",{id:"controlling-the-entire-synchronization-mechanism"},(0,a.kt)("a",{parentName:"h5",href:"https://github.com/wix/detox/blob/master/docs/APIRef.DeviceObjectAPI.md#devicedisablesynchronization"},"Controlling the entire synchronization mechanism")),(0,a.kt)("p",null,"The synchronization mechanism can be shut down using"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await device.disableSynchronization();\n")),(0,a.kt)("p",null,"to turn it on again use"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await device.enableSynchronization();\n")),(0,a.kt)("h5",{id:"controlling-network-synchronization"},(0,a.kt)("a",{parentName:"h5",href:"https://github.com/wix/detox/blob/master/docs/APIRef.DeviceObjectAPI.md#deviceseturlblacklisturls"},"Controlling network synchronization")),(0,a.kt)("p",null,"You can skip over synchronizing on certain URLs (for long polling tasks, or websocket connections)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await device.setURLBlacklist(['.*127.0.0.1.*']);\n")),(0,a.kt)("p",null,"In order to gain sync back on an endpoint, just remove it from the blacklist:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await device.setURLBlacklist([]);\n")),(0,a.kt)("p",null,"Alternatively, you can launch your app already with the URL blacklist defined \u2014 that can help with a network sync issue at the very beginning:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await device.launchApp({\n  launchArgs: {\n    detoxURLBlacklistRegex: '(\".*example.com/some-url/.*\")',\n  },\n});\n")),(0,a.kt)("h4",{id:"how-do-we-wait-manually"},"How do we wait manually?"),(0,a.kt)("p",null,"This makes sense only if we're not waiting enough (or if we've disabled automatic synchronization). Use the ",(0,a.kt)("inlineCode",{parentName:"p"},"withTimeout()")," API to wait until an expectation is met. The API is documented ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/wix/detox/docs/api/expect#withtimeouttimeout"},"here"),"."),(0,a.kt)("h3",{id:"tweaking-and-fine-tuning-the-synchronization-mechanisms"},"Tweaking and fine-tuning the synchronization mechanisms"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This isn't exposed yet, TBD")),(0,a.kt)("h3",{id:"modifying-your-app-to-avoid-waiting-too-much"},"Modifying your app to avoid waiting too much"),(0,a.kt)("p",null,"When facing a synchronization issue and tweaking doesn't help, consider modifying your app. When Detox is having trouble synchronizing due to intense non-stopping activity, it may be a sign that your app is abusing resources."),(0,a.kt)("p",null,"You can also modify your app, for the sake of tests only, by using mocking. Read more ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/master/docs/Guide.Mocking.md"},"here"),"."),(0,a.kt)("h4",{id:"settimeout-and-setinterval"},"setTimeout and setInterval"),(0,a.kt)("p",null,"By default, Detox is designed to ignore ",(0,a.kt)("inlineCode",{parentName:"p"},"setInterval")," and will only wait for ",(0,a.kt)("inlineCode",{parentName:"p"},"setTimeout")," of up to 1.5 seconds. If you have an endless polling loop with short intervals implemented with ",(0,a.kt)("inlineCode",{parentName:"p"},"setTimeout"),", switch the implementation to ",(0,a.kt)("inlineCode",{parentName:"p"},"setInterval"),". If possible, avoid aggressive polling in your app altogether, the poor single JavaScript thread we have doesn't like it."),(0,a.kt)("h4",{id:"endless-looping-animations"},"Endless looping animations"),(0,a.kt)("p",null,"By default, Detox will wait until animations complete. If you have an endless looping animation, this may cause Detox to hang. In this case, consider turning off the animation synchronization or remove the endless loop in your E2E build with ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/master/docs/Guide.Mocking.md"},"mocking"),"."))}p.isMDXComponent=!0}}]);
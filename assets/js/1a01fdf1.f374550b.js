"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[656],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),i=n(6010);const o="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o,r),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(7462),i=n(7294),o=n(6010),r=n(2389),s=n(7392),l=n(7094),p=n(2466);const c="tabList__CuJ",d="tabItem_LNqP";function m(e){var t;const{lazy:n,block:r,defaultValue:m,values:u,groupId:h,className:g}=e,k=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=u??k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,s.l)(f,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===m?m:m??(null==(t=k.find((e=>e.props.default)))?void 0:t.props.value)??k[0].props.value;if(null!==N&&!f.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:b,setTabGroupChoices:w}=(0,l.U)(),[y,x]=(0,i.useState)(N),C=[],{blockElementScrollPositionUntilNextRender:j}=(0,p.o5)();if(null!=h){const e=b[h];null!=e&&e!==y&&f.some((t=>t.value===e))&&x(e)}const D=e=>{const t=e.currentTarget,n=C.indexOf(t),a=f[n].value;a!==y&&(j(t),x(a),null!=h&&w(h,String(a)))},T=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;n=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;n=C[t]??C[C.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,o.Z)("tabs-container",c)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":r},g)},f.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:y===t?0:-1,"aria-selected":y===t,key:t,ref:e=>C.push(e),onKeyDown:T,onFocus:D,onClick:D},r,{className:(0,o.Z)("tabs__item",d,null==r?void 0:r.className,{"tabs__item--active":y===t})}),n??t)}))),n?(0,i.cloneElement)(k.filter((e=>e.props.value===y))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==y})))))}function u(e){const t=(0,r.Z)();return i.createElement(m,(0,a.Z)({key:String(t)},e))}},8028:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>v,contentTitle:()=>k,default:()=>w,frontMatter:()=>g,metadata:()=>f,toc:()=>N});var a=n(7462),i=(n(7294),n(3905)),o=n(5488),r=n(5162);const s={toc:[]};function l(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"UML sequence diagram",src:n(8697).Z,width:"1190",height:"831"})))}l.isMDXComponent=!0;const p={toc:[]};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"UML sequence diagram",src:n(6771).Z,width:"962",height:"682"})))}c.isMDXComponent=!0;const d={toc:[]};function m(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"UML sequence diagram",src:n(2066).Z,width:"842",height:"743"})))}m.isMDXComponent=!0;const u={toc:[]};function h(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"UML sequence diagram",src:n(945).Z,width:"598",height:"565"})))}h.isMDXComponent=!0;const g={},k="Internals API",f={unversionedId:"api/internals",id:"api/internals",title:"Internals API",description:"This section might be more volatile than the other ones, yet we'll do our best to adhere to Semantic Release standards even here.",source:"@site/../docs/api/internals.mdx",sourceDirName:"api",slug:"/api/internals",permalink:"/Detox/docs/next/api/internals",draft:!1,editUrl:"https://github.com/wix/Detox/edit/master/docs/../docs/api/internals.mdx",tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Logger",permalink:"/Detox/docs/next/api/logger"},next:{title:"Design Principles",permalink:"/Detox/docs/next/articles/design-principles"}},v={},N=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Jest lifecycle",id:"jest-lifecycle",level:3},{value:"Detox lifecycle",id:"detox-lifecycle",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>resolveConfig([options])</code> [Promise&lt;RuntimeConfig&gt;]",id:"resolveconfigoptions-promiseruntimeconfig",level:3},{value:"<code>getStatus()</code> [enum]",id:"getstatus-enum",level:3},{value:"<code>init([options])</code> [Promise]",id:"initoptions-promise",level:3},{value:"<code>installWorker([options])</code> [Promise]",id:"installworkeroptions-promise",level:3},{value:"<code>uninstallWorker()</code> [Promise]",id:"uninstallworker-promise",level:3},{value:"<code>cleanup()</code> [Promise]",id:"cleanup-promise",level:3},{value:"Optional lifecycle",id:"optional-lifecycle",level:2},{value:"<code>reportTestResults(array)</code> [Promise]",id:"reporttestresultsarray-promise",level:3},{value:"<code>onRunDescribeStart(event)</code> [Promise]",id:"onrundescribestartevent-promise",level:3},{value:"<code>onTestStart(event)</code> [Promise]",id:"onteststartevent-promise",level:3},{value:"<code>onHookFailure(event)</code> [Promise]",id:"onhookfailureevent-promise",level:3},{value:"<code>onTestFnFailure(event)</code> [Promise]",id:"ontestfnfailureevent-promise",level:3},{value:"<code>onTestDone(event)</code> [Promise]",id:"ontestdoneevent-promise",level:3},{value:"<code>onRunDescribeFinish(event)</code> [Promise]",id:"onrundescribefinishevent-promise",level:3},{value:"Properties",id:"properties",level:2},{value:"<code>config</code> [RuntimeConfig]",id:"config-runtimeconfig",level:3},{value:"<code>session</code> [SessionState]",id:"session-sessionstate",level:3},{value:"<code>log</code> [Logger]",id:"log-logger",level:3},{value:"<code>tracing</code>",id:"tracing",level:3},{value:"<code>tracing.createEventStream()</code>",id:"tracingcreateeventstream",level:4},{value:"<code>worker</code> [object]",id:"worker-object",level:3}],b={toc:N};function w(e){let{components:t,...s}=e;return(0,i.kt)("wrapper",(0,a.Z)({},b,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"internals-api"},"Internals API"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This section might be more volatile than the other ones, yet we'll do our best to adhere to Semantic Release standards even here.")),(0,i.kt)("p",null,"Detox Internals might be useful for developing advanced enterprise presets or if you are planning to integrate with a third-party test runner like ",(0,i.kt)("a",{parentName:"p",href:"https://mochajs.org"},"Mocha"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/avajs/ava"},"Ava"),", ",(0,i.kt)("a",{parentName:"p",href:"https://vitest.dev"},"Vitest")," or other ones."),(0,i.kt)("h2",{id:"lifecycle"},"Lifecycle"),(0,i.kt)("p",null,"The purpose of ",(0,i.kt)("strong",{parentName:"p"},"Internals API")," is mostly to align the lifecycles of Detox and a test runner underneath.\nAlthough it is generic enough, there is no denying that its design has been influenced by our official integration with Jest test runner.\nThat's why it might be better to start the overview from Jest lifecycle first, and then move on to Detox lifecycle and how they fit together."),(0,i.kt)("h3",{id:"jest-lifecycle"},"Jest lifecycle"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"UML sequence diagram",src:n(1183).Z,width:"717",height:"594"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Jest's main process starts from resolving and evaluating its config file, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"jest.config.js"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  return {\n    globalSetup: '/path/to/globalSetup.js',\n    globalTeardown: '/path/to/globalTeardown.js',\n    reporters: ['/path/to/reporter.js'],\n    /* ... jest config ... */\n  };\n};\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If a ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalsetup-string"},(0,i.kt)("inlineCode",{parentName:"a"},"globalSetup"))," handler is defined, it is resolved and executed in the main process:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  // ... global setup code ...\n};\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The next come ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#reporters-arraymodulename--modulename-options"},(0,i.kt)("inlineCode",{parentName:"a"},"reporters")),", one of the longest-lived entities in the test session. After instantiating reporters, Jest calls their ",(0,i.kt)("inlineCode",{parentName:"p"},"onRunStart")," method:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onRunStart(aggregatedResults, options) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If Jest is not running in band (see ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/cli#--runinband"},(0,i.kt)("inlineCode",{parentName:"a"},"-i, --runInBand")),"), and if it has ",(0,i.kt)("em",{parentName:"p"},"N")," ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#maxworkers-number--string"},"workers")," (",(0,i.kt)("em",{parentName:"p"},"N > 1"),"), then it spawns ",(0,i.kt)("em",{parentName:"p"},"N")," child processes that keep taking test files one after another, running their tests inside and reporting back to the reporters:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onTestFileResult(test, testResult, aggregatedResult) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n")),(0,i.kt)("p",{parentName:"li"},"Otherwise, Jest runs the tests in the main process without spawning any other processes. The reporting flow remains the same:"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("img",{alt:"UML sequence diagram",src:n(6086).Z,width:"591",height:"616"}))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After all the tests have been executed, Jest calls ",(0,i.kt)("inlineCode",{parentName:"p"},"onRunComplete")," in the reporters. This is the last time when a reporter can take control:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class Reporter {\n  async onRunComplete(testContexts, results) {\n    // ... reporter code ...\n  }\n\n  // ...\n};\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The last user-controlled hook is the global teardown. If a ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalteardown-string"},(0,i.kt)("inlineCode",{parentName:"a"},"globalTeardown"))," handler is defined, it is resolved and executed in the main process:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = async function () {\n  // ... global teardown code ...\n};\n")))),(0,i.kt)("h3",{id:"detox-lifecycle"},"Detox lifecycle"),(0,i.kt)("p",null,"On one hand, Detox CLI can be totally agnostic about a test runner under the hood, but that would deprive us of some conveniences.\nFor instance, there is a ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/config/testRunner#testrunnerretries-number"},"retry mechanism"),", built into Detox CLI, which can schedule extra runs for failed test files.\nThis means that Detox context should live longer than any test runner, and the test runner should have means to report back to Detox CLI, whereas the resulting child process hierarchy can be broad and multi-tiered, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:"text",text:!0},"\u2514\u2500\u2500 detox test ...\n    \u2514\u2500\u2500 jest ... --maxWorkers N\n        \u251c\u2500\u2500 jest-worker (1)\n        \u251c\u2500\u2500 ...\n        \u2514\u2500\u2500 jest-worker (N)\n")),(0,i.kt)("p",null,"Even we run Jest directly, without Detox CLI, there's still a one-to-many relationship between its processes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:"text",text:!0},"\u2514\u2500\u2500 jest ... --maxWorkers N\n    \u251c\u2500\u2500 jest-worker (1)\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 jest-worker (N)\n")),(0,i.kt)("p",null,"So, if we want to be on the safe side, every process should be able to communicate with the root process, where we have the primary context of Detox, and vice versa.\nRetrying failed tests is just one of numerous needs, and there are more:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the primary context (and workers themselves, at times) needs to know how many workers are there;"),(0,i.kt)("li",{parentName:"ul"},"the workers should request from the primary context to allocate a device and return it back when they are done;"),(0,i.kt)("li",{parentName:"ul"},"any secondary context should be able to tell whether this is a first time it is running, or it is an ",(0,i.kt)("em",{parentName:"li"},"N"),"-th attempt already;")),(0,i.kt)("p",null,"This list can be continued and might expand even more with time, but the point is that Detox contexts will get instantiated as many times as child processes are created during the test session, and it should be something trivial to synchronize the primary and the secondary contexts to ensure a seamless experience."),(0,i.kt)("p",null,'It is worth mentioning that Jest\'s main process is ill-suited for taking a device and running the tests, as its purpose is to orchestrate the entire test session and not run the tests themselves.\nThis means that not all secondary contexts of Detox are "born equal" \u2013 most of them will be allocating a device for running tests, but some will be merely communicating with the primary context.'),(0,i.kt)("p",null,"This is exactly the reason why we call ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," in every child process, but sometimes it is not just a simple call, but an ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init({ workerId: null })"))," override to avoid creating a worker.\nHowever, the fact of initializing without a worker does not mean we can't call ",(0,i.kt)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"installWorker()"))," later. For example, if it turns out that Jest is running in a single process, then instead of creating two contexts within the same process, we're going to reuse the existing one and just supplement it with the worker itself."),(0,i.kt)("p",null,"There's one more implicit thing that happens at the very beginning of ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init([options])"))," method, and this is the config resolution. It is also available as a separate method, ",(0,i.kt)("a",{parentName:"p",href:"#resolveconfigoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"resolveConfig([options])"))," based on the following considerations.\nWhen you use a test runner directly, without Detox CLI (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"jest \u2026")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"detox test \u2026"),"), then the test runner config gets resolved earlier than Detox config itself. That creates a dangerous scenario for dynamically generated configs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="jest.config.js"',title:'"jest.config.js"'},"const { config } = require('detox/internals');\n\nmodule.exports = async () => {\n  if (config.device.type === 'ios.simulator') {\n    return { /* iOS-specific preset */ };\n  } else {\n    return { /* Android-specific preset */ };\n  }\n};\n")),(0,i.kt)("p",null,"The problem in this case is that we are accessing an unresolved (yet) config. Of course, one could assume that it is possible to overcome with a plain ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," call like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="bad-idea.config.js"',title:'"bad-idea.config.js"'},"const { init, config } = require('detox/internals');\n\nmodule.exports = async () => {\n  await init();\n\n  if (config.device.type === 'ios.simulator') {\n    // ... use config now ...\n  }\n};\n")),(0,i.kt)("p",null,"This solution will work, but it is rather a bad one, since Jest config resolution is an asymmetrical step compared to ",(0,i.kt)("inlineCode",{parentName:"p"},"globalSetup")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"globalTeardown"),". While solving one problem, it creates another one. Consider running this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"jest --config bad-idea.config.js --showConfig\n")),(0,i.kt)("p",null,"For reference, when Jest runs with a ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/cli#--showconfig"},(0,i.kt)("inlineCode",{parentName:"a"},"--showConfig"))," option, all it does is ",(0,i.kt)("em",{parentName:"p"},"to resolve the config and to print it"),". Hence, neither ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalsetup-string"},(0,i.kt)("inlineCode",{parentName:"a"},"globalSetup"))," nor ",(0,i.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/configuration#globalteardown-string"},(0,i.kt)("inlineCode",{parentName:"a"},"globalTeardown"))," will be called, and the test runner will hang up since there's no one to call the ",(0,i.kt)("a",{parentName:"p",href:"#cleanup-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup()"))," method which stops the ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/node-ipc"},"IPC server")," used for the communication between the primary and the secondary contexts."),(0,i.kt)("p",null,"Still, we have to be able to access the config early, and that is exactly why ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," method is a composite of ",(0,i.kt)("a",{parentName:"p",href:"#resolveconfigoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"resolveConfig()")),", the ",(0,i.kt)("em",{parentName:"p"},"actual")," init, and ",(0,i.kt)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"installWorker()")),". We could describe what it does on the high level with the following pseudocode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"async function init(options = {}) {\n  config = config || await resolveConfig();\n\n  await logger.init(config);\n  await ipcServer.init(config);\n  // ... init more things  ...\n\n  if (options.workerId != null) {\n    await installWorker();\n  }\n}\n")),(0,i.kt)("p",null,"In other words, it will resolve config only if it has not been resolved before, and install a worker unless it has been forbidden explicitly.\nAnd even that we can ",(0,i.kt)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"installWorker()"))," later if we ever need it."),(0,i.kt)("p",null,"Now, when many details are clarified, we can review the actual sequence diagrams step by step. There are four scenarios depending on the initiator (Detox CLI or the test runner itself) and on child process hierarchy (a single process or parent-children)."),(0,i.kt)("p",null,"A few words about the diagram and its conventions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"ClassName.0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ClassName.1"),", \u2026, ",(0,i.kt)("inlineCode",{parentName:"li"},"ClassName.N")," suffixes mean the index of the instance of the class created."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DetoxCircusEnvironment.N")," is our custom ",(0,i.kt)("a",{parentName:"li",href:"https://jestjs.io/docs/configuration#testenvironment-string"},(0,i.kt)("inlineCode",{parentName:"a"},"testEnvironment"))," created one or multiple times in every Jest worker. Make sure to read about Jest ",(0,i.kt)("a",{parentName:"li",href:"https://jestjs.io/docs/configuration#testenvironment-string"},"test environments")," and look at the example section there for better understanding.")),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"detox test \u2026 --maxWorkers N",mdxType:"TabItem"},(0,i.kt)(l,{mdxType:"LifecycleManyWorkersCLI"})),(0,i.kt)(r.Z,{value:"jest \u2026 --maxWorkers N",mdxType:"TabItem"},(0,i.kt)(c,{mdxType:"LifecycleManyWorkersJest"})),(0,i.kt)(r.Z,{value:"detox test \u2026 --runInBand",mdxType:"TabItem"},(0,i.kt)(m,{mdxType:"LifecycleSingleWorkerCLI"})),(0,i.kt)(r.Z,{value:"jest \u2026 --runInBand",mdxType:"TabItem"},(0,i.kt)(h,{mdxType:"LifecycleSingleWorkerJest"}))),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Feel free to browse through ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/next/detox/internals.d.ts"},"the typings file")," provided by Detox.")),(0,i.kt)("h3",{id:"resolveconfigoptions-promiseruntimeconfig"},(0,i.kt)("inlineCode",{parentName:"h3"},"resolveConfig([options])")," ","[","Promise<RuntimeConfig",">","]"),(0,i.kt)("p",null,"Use sparingly for cases when you need to read Detox config before ",(0,i.kt)("a",{parentName:"p",href:"#initoptions-promise"},"init()")," is called."),(0,i.kt)("p",null,"If you use Detox with Jest, the only place where you might need it is your ",(0,i.kt)("inlineCode",{parentName:"p"},"jest.config.js"),", e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="jest.config.js"',title:'"jest.config.js"'},"const { resolveConfig } = require('detox/internals');\n\nmodule.exports = async () => {\n  /** @type {DetoxInternals.RuntimeConfig} */\n  const config = await resolveConfig();\n\n  return { /* Jest config with  */ };\n};\n")),(0,i.kt)("p",null,"Please mind, though, that Detox allows to override test runner options via config, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="detox.config.js"',title:'"detox.config.js"'},"/** @type {Detox.DetoxConfig} */\nmodule.exports = {\n  apps: { /* ... */ },\n  devices: { /* ... */ },\n  configurations: {\n    'ios.sim.debug': {\n      app: 'ios.debug',\n      device: 'iphone',\n      testRunner: {\n        args: {\n// highlight-next-line\n          maxWorkers: process.env.CI === 'true' ? 3 : undefined,\n        },\n      },\n    },\n    'android.emu.debug': {\n      app: 'android.debug',\n      device: 'nexus',\n      testRunner: {\n        args: {\n// highlight-next-line\n          maxWorkers: process.env.CI === 'true' ? 2 : undefined,\n        },\n      },\n    },\n  },\n};\n")),(0,i.kt)("h3",{id:"getstatus-enum"},(0,i.kt)("inlineCode",{parentName:"h3"},"getStatus()")," ","[","enum]"),(0,i.kt)("p",null,"Returns one of statuses depending on what\u2019s going on:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inactive")," \u2013 before ",(0,i.kt)("a",{parentName:"li",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," and after ",(0,i.kt)("a",{parentName:"li",href:"#cleanup-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup()"))," is called."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"init")," \u2013 while ",(0,i.kt)("a",{parentName:"li",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," is executing."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"active")," \u2013 after ",(0,i.kt)("a",{parentName:"li",href:"#initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"init()"))," and before ",(0,i.kt)("a",{parentName:"li",href:"#cleanup-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup()"))," is called."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cleanup")," \u2013 while ",(0,i.kt)("a",{parentName:"li",href:"#cleanup-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup"))," is executing.")),(0,i.kt)("h3",{id:"initoptions-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"init([options])")," ","[","Promise]"),(0,i.kt)("p",null,"This is the phase where Detox reads its configuration, starts a server."),(0,i.kt)("p",null,"Accepts an optional parameter, ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," object with the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cwd")," (string) \u2013 current working directory, used to ",(0,i.kt)("a",{parentName:"li",href:"/Detox/docs/next/config/overview#path-conventions"},"resolve Detox config"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"argv")," (key-value map) \u2013 CLI overrides"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testRunnerArgv")," (key-value map) \u2013 TODO"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"override")," (Partial<Detox.DetoxConfig",">",") \u2013 TODO"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"global")," \u2013 reference to a custom ",(0,i.kt)("a",{parentName:"li",href:"https://nodejs.org/api/globals.html"},"global")," scope. Use it when needed because of Jest sandboxing. TODO"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"workerId")," \u2013 TODO")),(0,i.kt)("h3",{id:"installworkeroptions-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"installWorker([options])")," ","[","Promise]"),(0,i.kt)("p",null,"This is the phase where Detox loads its expectation library and starts a device."),(0,i.kt)("p",null,"Accepts an optional parameter, ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," object with the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"global")," \u2013 TODO"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"workerId")," \u2013 TODO")),(0,i.kt)("h3",{id:"uninstallworker-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"uninstallWorker()")," ","[","Promise]"),(0,i.kt)("p",null,"Deallocates the device."),(0,i.kt)("h3",{id:"cleanup-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"cleanup()")," ","[","Promise]"),(0,i.kt)("p",null,"The global cleanup phase should happen after all the tests have finished.\nThis is the phase where the Detox server shuts down."),(0,i.kt)("h2",{id:"optional-lifecycle"},"Optional lifecycle"),(0,i.kt)("h3",{id:"reporttestresultsarray-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"reportTestResults(array)")," ","[","Promise]"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This method has an effect only when the tests are run via ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/cli/test"},"Detox CLI"),".")),(0,i.kt)("p",null,"Reports to the primary context about failed tests that could have been re-run if ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/cli/test#options"},(0,i.kt)("inlineCode",{parentName:"a"},"-R, --retries"))," is a positive number."),(0,i.kt)("p",null,"It takes one argument, an array of test file reports. Each report is an object with the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testFilePath")," (string) \u2014 global or relative path to the failed test file;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"success")," (boolean) \u2014 whether the test passed or not;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testExecError")," (optional error) \u2014 top-level error if the entire test file failed;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isPermanentFailure")," (optional boolean) \u2014 if the test failed, it should tell whether the failure is permanent. Permanent failure means that the test file should not be re-run.")),(0,i.kt)("h3",{id:"onrundescribestartevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onRunDescribeStart(event)")," ","[","Promise]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onRunDescribeStart({\n  name: 'Suite name'\n});\n")),(0,i.kt)("h3",{id:"onteststartevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onTestStart(event)")," ","[","Promise]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onTestStart({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 1,\n  status: 'running',\n});\n")),(0,i.kt)("h3",{id:"onhookfailureevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onHookFailure(event)")," ","[","Promise]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onHookFailure({\n  error: new Error('Some assertion failed'),\n  hook: 'beforeEach',\n});\n")),(0,i.kt)("h3",{id:"ontestfnfailureevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onTestFnFailure(event)")," ","[","Promise]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onTestFnFailure({ error: new Error('Some assertion failed') });\n")),(0,i.kt)("h3",{id:"ontestdoneevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onTestDone(event)")," ","[","Promise]"),(0,i.kt)("p",null,"Reports the final status of the test, ",(0,i.kt)("inlineCode",{parentName:"p"},"passed")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"failed"),", e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onTestDone({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 1,\n  status: 'failed',\n  timedOut: false,\n});\n")),(0,i.kt)("p",null,"And, for example, if your test passes on the second attempt:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onTestDone({\n  title: 'should do something expected',\n  fullName: 'Suite name should do something expected',\n  invocations: 2,\n  status: 'passed',\n});\n")),(0,i.kt)("h3",{id:"onrundescribefinishevent-promise"},(0,i.kt)("inlineCode",{parentName:"h3"},"onRunDescribeFinish(event)")," ","[","Promise]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await onRunDescribeFinish({ name: 'Suite name' });\n")),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("h3",{id:"config-runtimeconfig"},(0,i.kt)("inlineCode",{parentName:"h3"},"config")," ","[","RuntimeConfig]"),(0,i.kt)("p",null,"Open ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/wix/Detox/blob/next/detox/internals.d.ts"},"the typings file")," and search for ",(0,i.kt)("inlineCode",{parentName:"p"},"RuntimeConfig"),"."),(0,i.kt)("p",null,"For the most part, this config is identical to what we describe in ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/config/overview"},"Config docs"),", except that it is non-optional.\nIn other words, even if you never customized your ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/config/session"},"Session config"),", you'll still be able to access some default\nvalues safely, without null checks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { config } = require('detox/internals');\ntypeof config.session.autoStart // \"boolean\"\n")),(0,i.kt)("h3",{id:"session-sessionstate"},(0,i.kt)("inlineCode",{parentName:"h3"},"session")," ","[","SessionState]"),(0,i.kt)("p",null,"The session state contains the following read-only properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"id")," (string) \u2013 randomly generated ID for the entire Detox test session, including retries."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testResults")," (DetoxTestFileReport[]) \u2013 results of the prior test file executions, used by Detox CLI retry mechanism."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testSessionIndex")," (number) \u2013 the retry index of the test session: ",(0,i.kt)("inlineCode",{parentName:"li"},"0..<retriesCount>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"workersCount")," (number) \u2013 count of Detox contexts with a worker installed.\nIf we oversimplify it, it reflects the count of allocated devices in the current test session.")),(0,i.kt)("p",null,"The session state, including the resolved config, is serialized by the primary context, so that the secondary Detox contexts can read it synchronously from a file at the earliest point possible.\nAfter the secondary contexts connect to the IPC server hosted by the primary context, they register themselves and get the up-to-date session state.\nThe IPC server broadcasts the updates to all the connected contexts on every action like ",(0,i.kt)("a",{parentName:"p",href:"#installworkeroptions-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"installWorker()"))," or ","[",(0,i.kt)("inlineCode",{parentName:"p"},"reportTestResults()"),"][reportTestResults]","."),(0,i.kt)("h3",{id:"log-logger"},(0,i.kt)("inlineCode",{parentName:"h3"},"log")," ","[","Logger]"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/Detox/docs/next/api/logger"},"Logger API")," for all the details."),(0,i.kt)("p",null,"The only difference from the Client API here is that you don't have a predefined ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," category, i.e.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { log: logClient } = require('detox');\nconst { log: logInternal } = require('detox/internals');\n\n// oversimplified, it looks like:\nlogClient == logInternal.child({ cat: 'user' })\n")),(0,i.kt)("p",null,"For example, we leverage this for adding more ",(0,i.kt)("inlineCode",{parentName:"p"},"lifecycle")," events in our integration with Jest:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="detox/runners/jest/testEnvironment/index.js"',title:'"detox/runners/jest/testEnvironment/index.js"'},"class DetoxCircusEnvironment extends NodeEnvironment {\n  constructor(config, context) {\n    super(/* ... */);\n    log.trace.begin({ cat: 'lifecycle' }, context.testPath);\n    // ...\n  }\n}\n")),(0,i.kt)("h3",{id:"tracing"},(0,i.kt)("inlineCode",{parentName:"h3"},"tracing")),(0,i.kt)("p",null,"An advanced API useful for creating reports based on logged Detox events."),(0,i.kt)("h4",{id:"tracingcreateeventstream"},(0,i.kt)("inlineCode",{parentName:"h4"},"tracing.createEventStream()")),(0,i.kt)("p",null,"Creates a readable stream of the currently recorded events in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU"},"Chrome Trace Event format"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tracing } = require('detox/internals');\n\nasync function processDetoxEvents() {\n  await new Promise((resolve, reject) => {\n    tracing\n      .createEventStream()\n      .on('end', resolve)\n      .on('error', reject)\n      .on('data', (event) => {\n        if (event.ph === 'B') { /* duration event (begin) */ }\n        if (event.ph === 'E') { /* duration event (end) */ }\n        if (event.ph === 'i') { /* instant event */ }\n      });\n  });\n}\n")),(0,i.kt)("p",null,"Please mind that you'll be getting a snapshot of events aggregated from all the sibling and child processes, and it never will be complete until the very end of the test session."),(0,i.kt)("p",null,"See also: ",(0,i.kt)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/DurationBeginEvent.html"},(0,i.kt)("inlineCode",{parentName:"a"},"DurationBeginEvent")),", ",(0,i.kt)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/DurationEndEvent.html"},(0,i.kt)("inlineCode",{parentName:"a"},"DurationEndEvent")),", ",(0,i.kt)("a",{parentName:"p",href:"https://wix-incubator.github.io/trace-event-lib/interfaces/InstantEvent.html"},(0,i.kt)("inlineCode",{parentName:"a"},"InstantEvent")),"."),(0,i.kt)("h3",{id:"worker-object"},(0,i.kt)("inlineCode",{parentName:"h3"},"worker")," ","[","object]"),(0,i.kt)("p",null,"Not documented on purpose. Provides the direct access to the object which holds the device driver, websocket client, matchers, expectations, etc."))}w.isMDXComponent=!0},8697:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/boot-cli-many-workers-95ab2193ce10864c0742f01ffd30b58b.svg"},2066:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/boot-cli-single-worker-6672b7356e2146d40f39f80145780949.svg"},6771:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/boot-jest-many-workers-ce60aaacc2101a9b810d2d22fe0df51b.svg"},945:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/boot-jest-single-worker-278e1383ad4f31570f073fa12689aec6.svg"},6086:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/jest-diagram-runInBand-b0e7564080d4f6a0a03e4dbcf6b0da7f.svg"},1183:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/jest-diagram-d957dd3e62301816b44197ef0a4abee0.svg"}}]);